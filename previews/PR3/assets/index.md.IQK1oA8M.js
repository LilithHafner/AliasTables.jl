import{_ as e,c as s,o as a,a7 as t}from"./chunks/framework.D5e1XSJx.js";const T=JSON.parse('{"title":"OffsetTables","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":null}'),i={name:"index.md"},l=t('<h1 id="OffsetTables" tabindex="-1">OffsetTables <a class="header-anchor" href="#OffsetTables" aria-label="Permalink to &quot;OffsetTables {#OffsetTables}&quot;">​</a></h1><p>Documentation for <a href="https://github.com/LilithHafner/OffsetTables.jl" target="_blank" rel="noreferrer">OffsetTables</a>.</p><ul><li><a href="#OffsetTables.OffsetTable"><code>OffsetTables.OffsetTable</code></a></li><li><a href="#OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{T, OffsetTable{T, I}}} where {T, I}"><code>OffsetTables.sample</code></a></li><li><a href="#OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{Random.AbstractRNG, OffsetTable{T, I}}} where {T, I}"><code>OffsetTables.sample</code></a></li></ul><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="OffsetTables.OffsetTable" href="#OffsetTables.OffsetTable">#</a> <b><u>OffsetTables.OffsetTable</u></b> — <i>Type</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OffsetTable{T&lt;:Unsigned=UInt, I&lt;:Integer=Int}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(weights</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector{&lt;:Real}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; normalize</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>An efficient data structure for sampling from a discrete distribution.</p><p>Maps every value representable by <code>T</code> to a value of type <code>I</code> in <code>eachindex(wights)</code> such that the number of values maped to a given index of <code>weights</code> is proportional to the value at that index.</p><p>The mapping can be accessed directly via <a href="/previews/PR3/index#OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{T, OffsetTable{T, I}}} where {T, I}"><code>OffsetTables.sample(x::T, ot::OffsetTable{T, I})</code></a> or indirectly by passing a random number generator which will be used to generate a random input of type <code>T</code> for you via <a href="/previews/PR3/index#OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{Random.AbstractRNG, OffsetTable{T, I}}} where {T, I}"><code>OffsetTables.sample(rng::Random.AbstractRNG, ot::OffsetTable{T, I})</code></a> or simply via the <code>Random</code> API: <code>rand(ot)</code>, <code>rand(rng, ot)</code>, <code>rand(ot, dims...)</code>, etc.</p><p>Set <code>normalize = false</code> for incrased performance when the weights are already normalized to sum to exactly the number of values representable by <code>T</code> (i.e. <code>typemax(T)+1</code>). A different sum will result in an error unless exactly one weight is non-zero, in which case the sum is not checked and the <code>OffsetTable</code> represents a constant distribution which always produces the index of the nonzero weight.</p><p><a href="https://github.com/LilithHafner/OffsetTables.jl/blob/ed25a6038703173a8c02a17f14511ecfa7d0dbe6/src/OffsetTables.jl#L8-L29" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{Random.AbstractRNG, OffsetTable{T, I}}} where {T, I}" href="#OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{Random.AbstractRNG, OffsetTable{T, I}}} where {T, I}">#</a> <b><u>OffsetTables.sample</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Random.AbstractRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OffsetTable{T, I}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> I</span></span></code></pre></div><p>Sample from <code>ot</code> using randomness drawn from <code>rng</code>.</p><p>Produces a random sample from the distribution represented by <code>ot</code>.</p><p>See also <a href="/previews/PR3/index#OffsetTables.OffsetTable"><code>OffsetTable</code></a>, <code>Random.rand</code></p><p><a href="https://github.com/LilithHafner/OffsetTables.jl/blob/ed25a6038703173a8c02a17f14511ecfa7d0dbe6/src/OffsetTables.jl#L169-L177" target="_blank" rel="noreferrer">source</a></p></div><br><div style="border-width:1px;border-style:solid;border-color:black;padding:1em;border-radius:25px;"><a id="OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{T, OffsetTable{T, I}}} where {T, I}" href="#OffsetTables.sample-Union{Tuple{I}, Tuple{T}, Tuple{T, OffsetTable{T, I}}} where {T, I}">#</a> <b><u>OffsetTables.sample</u></b> — <i>Method</i>. <div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sample</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">OffsetTable{T, I}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> I</span></span></code></pre></div><p>Sample from <code>ot</code> using the seed <code>x</code>.</p><p>If <code>x</code> is chosen uniformly at random from the set of all values representable by <code>T</code> then the output will be a random sample from the distribution represented by <code>ot</code>. The mapping is deterministic and not pseudo-random so for patterned input <code>x</code> the output will be patterned as well.</p><p>See also <a href="/previews/PR3/index#OffsetTables.OffsetTable"><code>OffsetTable</code></a></p><p><a href="https://github.com/LilithHafner/OffsetTables.jl/blob/ed25a6038703173a8c02a17f14511ecfa7d0dbe6/src/OffsetTables.jl#L146-L157" target="_blank" rel="noreferrer">source</a></p></div><br>',9),r=[l];function o(d,n,p,h,f,c){return a(),s("div",null,r)}const u=e(i,[["render",o]]);export{T as __pageData,u as default};
